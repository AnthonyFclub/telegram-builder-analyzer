# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Gp9miNST2kmo43_WLM3ainx6yKytSFRo
"""

import json
import pandas as pd

# Cargar el archivo JSON
try:
    with open('result.json', 'r', encoding='utf-8') as file:
        data = json.load(file)
    print("✓ Archivo JSON cargado exitosamente")
except Exception as e:
    print(f"✗ Error al cargar el archivo: {e}")

# Verificar la estructura básica
print("\nExplorando estructura del JSON:")
if 'data' in locals():
    print("Claves principales:", list(data.keys()))

    # Ver si hay una estructura de chats
    if 'chats' in data:
        print(f"Número de chats: {len(data['chats'].get('list', []))}")

        # Imprimir nombres de los chats
        chat_names = [chat.get('name', 'Sin nombre') for chat in data['chats'].get('list', [])]
        print("Chats encontrados:", chat_names[:5], "..." if len(chat_names) > 5 else "")

        # Crear una lista simple para guardar información
        users_list = []

        # Procesar cada chat
        for chat in data['chats'].get('list', []):
            chat_name = chat.get('name', 'Sin nombre')
            print(f"\nAnalizando chat: {chat_name}")

            # Contar usuarios únicos en este chat
            unique_users = set()

            # Procesar mensajes si existen
            if 'messages' in chat:
                for msg in chat['messages']:
                    # Solo procesar mensajes con remitente
                    if 'from' in msg:
                        user = {
                            'ID': msg.get('from_id', ''),
                            'Username': msg.get('from', ''),
                            'Display Name': f"{msg.get('from_first_name', '')} {msg.get('from_last_name', '')}".strip(),
                            'Chat': chat_name,
                            'Last Activity': msg.get('date', '')
                        }

                        # Agregar a la lista si no existe ya
                        user_id = user['ID']
                        if user_id and user_id not in unique_users:
                            unique_users.add(user_id)
                            users_list.append(user)

                print(f"Usuarios únicos en este chat: {len(unique_users)}")

        # Crear DataFrame
        if users_list:
            df = pd.DataFrame(users_list)
            print(f"\nTotal de usuarios encontrados: {len(df)}")
            print("\nPrimeros 5 usuarios:")
            print(df.head())

            # Guardar a CSV
            df.to_csv('telegram_users.csv', index=False)
            print("\nResultados guardados en 'telegram_users.csv'")
            print("Puedes descargar este archivo desde el panel izquierdo")
        else:
            print("No se encontraron usuarios")
    else:
        print("No se encontró la estructura de chats esperada")
else:
    print("No se pudo cargar el JSON")

from google.colab import drive
drive.mount('/content/drive')

import os
print("Archivos en el directorio actual:")
!ls

# Crear un archivo JSON simplificado con la estructura visible
json_content = '''
{
  "about": "Aquí va alguna información",
  "personal_info": {
    "user_id": 72024,
    "first_name": "...",
    "last_name": "...",
    "phone_number": "...",
    "username": "@..."
  },
  "profile_pictures": [
    {
      "date": "2025-...",
      "date_unixtime": "...",
      "photo": "..."
    },
    // más entradas aquí
  ]
}
'''

# Guardar como un nuevo archivo
with open('telegram_data.json', 'w', encoding='utf-8') as f:
    f.write(json_content)

# Procesar este archivo
import json
import pandas as pd

try:
    with open('telegram_data.json', 'r', encoding='utf-8') as file:
        data = json.load(file)
    print("✓ Archivo JSON creado y cargado exitosamente")

    # Extraer información básica
    username = data.get('personal_info', {}).get('username', 'No disponible')
    user_id = data.get('personal_info', {}).get('user_id', 'No disponible')

    print(f"\nInformación del usuario:")
    print(f"Username: {username}")
    print(f"User ID: {user_id}")

    # Crear un CSV básico con esta información
    user_data = [{'Username': username, 'ID': user_id}]
    df = pd.DataFrame(user_data)
    df.to_csv('basic_user_info.csv', index=False)
    print("\nArchivo CSV básico creado con la información disponible")

except Exception as e:
    print(f"✗ Error: {e}")

# Buscar el archivo en todos los directorios
!find / -name "result.json" 2>/dev/null

# Acceder al archivo usando la ruta completa
import json
import pandas as pd

try:
    with open('/result.json', 'r', encoding='utf-8') as file:
        data = json.load(file)
    print("✓ Archivo JSON cargado exitosamente")

    # Extraer lista de mensajes directamente
    users = {}
    messages = []

    # Verificar la estructura del JSON
    print("Claves principales:", list(data.keys()))

    # Si hay una estructura de chats, extraer usuarios
    if 'chats' in data and 'list' in data['chats']:
        print(f"Encontrados {len(data['chats']['list'])} chats")

        for chat in data['chats']['list']:
            chat_name = chat.get('name', 'Sin nombre')
            print(f"\nProcesando chat: {chat_name}")

            if 'messages' in chat:
                print(f"  - {len(chat['messages'])} mensajes")

                for msg in chat['messages']:
                    if 'from' in msg:
                        user_id = msg.get('from_id', '')
                        username = msg.get('from', '')

                        if user_id and user_id not in users:
                            users[user_id] = {
                                'ID': user_id,
                                'Username': username,
                                'Display Name': f"{msg.get('from_first_name', '')} {msg.get('from_last_name', '')}".strip(),
                                'Last Activity': msg.get('date', ''),
                                'Chat': chat_name
                            }

        # Crear DataFrame con los usuarios únicos
        user_list = list(users.values())
        if user_list:
            df = pd.DataFrame(user_list)
            print(f"\nEncontrados {len(df)} usuarios únicos")
            print("\nPrimeros 5 usuarios:")
            print(df.head())

            # Guardar a CSV
            df.to_csv('telegram_users.csv', index=False)
            print("\nArchivo CSV guardado como 'telegram_users.csv'")
        else:
            print("No se encontraron usuarios")
    else:
        print("Estructura de chats no encontrada en el JSON")

except Exception as e:
    print(f"✗ Error: {e}")

# Acceder al archivo usando la ruta completa
import json
import pandas as pd

try:
    with open('/result.json', 'r', encoding='utf-8') as file:
        data = json.load(file)
    print("✓ Archivo JSON cargado exitosamente")

    # Extraer lista de mensajes directamente
    users = {}
    messages = []

    # Verificar la estructura del JSON
    print("Claves principales:", list(data.keys()))

    # Si hay una estructura de chats, extraer usuarios
    if 'chats' in data and 'list' in data['chats']:
        print(f"Encontrados {len(data['chats']['list'])} chats")

        for chat in data['chats']['list']:
            chat_name = chat.get('name', 'Sin nombre')
            print(f"\nProcesando chat: {chat_name}")

            if 'messages' in chat:
                print(f"  - {len(chat['messages'])} mensajes")

                for msg in chat['messages']:
                    if 'from' in msg:
                        user_id = msg.get('from_id', '')
                        username = msg.get('from', '')

                        if user_id and user_id not in users:
                            users[user_id] = {
                                'ID': user_id,
                                'Username': username,
                                'Display Name': f"{msg.get('from_first_name', '')} {msg.get('from_last_name', '')}".strip(),
                                'Last Activity': msg.get('date', ''),
                                'Chat': chat_name
                            }

        # Crear DataFrame con los usuarios únicos
        user_list = list(users.values())
        if user_list:
            df = pd.DataFrame(user_list)
            print(f"\nEncontrados {len(df)} usuarios únicos")
            print("\nPrimeros 5 usuarios:")
            print(df.head())

            # Guardar a CSV
            df.to_csv('telegram_users.csv', index=False)
            print("\nArchivo CSV guardado como 'telegram_users.csv'")
        else:
            print("No se encontraron usuarios")
    else:
        print("Estructura de chats no encontrada en el JSON")

except Exception as e:
    print(f"✗ Error: {e}")

import json
import pandas as pd
import re
from datetime import datetime

try:
    with open('/result.json', 'r', encoding='utf-8') as file:
        data = json.load(file)
    print("✓ Archivo JSON cargado exitosamente")

    # Diccionarios para identificar roles y habilidades
    role_keywords = {
        'Developer': ['desarrollador', 'programador', 'coder', 'engineer', 'ingeniero', 'dev', 'fullstack', 'frontend', 'backend'],
        'Designer': ['diseñador', 'designer', 'ux', 'ui', 'interfaz', 'figma', 'sketch'],
        'Product Manager': ['product manager', 'pm', 'product owner', 'gerente de producto', 'scrum'],
        'Marketing': ['marketing', 'growth', 'community manager', 'social media'],
        'Founder': ['founder', 'fundador', 'ceo', 'co-founder', 'emprendedor', 'startup']
    }

    tech_keywords = {
        'Frontend': ['react', 'vue', 'angular', 'javascript', 'typescript', 'html', 'css', 'frontend', 'front-end'],
        'Backend': ['node', 'express', 'django', 'flask', 'python', 'java', 'backend', 'back-end', 'api', 'servidor', 'server'],
        'Blockchain': ['solidity', 'web3', 'smart contract', 'ethereum', 'blockchain', 'token', 'crypto', 'nft', 'defi'],
        'AI/ML': ['machine learning', 'ml', 'ai', 'ia', 'inteligencia artificial', 'gpt', 'llm', 'claude', 'bard', 'chatgpt'],
        'Mobile': ['android', 'ios', 'swift', 'flutter', 'react native', 'móvil', 'mobile']
    }

    # Función para extraer wallet
    def extract_wallet(text):
        if isinstance(text, str):
            wallet_pattern = re.compile(r'0x[a-fA-F0-9]{40}')
            matches = wallet_pattern.findall(text)
            return matches[0] if matches else None
        return None

    # Función para detectar experiencia
    def detect_experience(messages, keywords):
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                for keyword in keywords:
                    if keyword in text:
                        return 'Yes'
        return None

    # Función para detectar habilidades técnicas
    def detect_skills(messages):
        skills = set()
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                for tech, keywords in tech_keywords.items():
                    if any(keyword in text for keyword in keywords):
                        skills.add(tech)
        return ', '.join(skills) if skills else None

    # Función para detectar rol primario
    def detect_primary_role(messages):
        role_counts = {role: 0 for role in role_keywords}
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                for role, keywords in role_keywords.items():
                    for keyword in keywords:
                        if keyword in text:
                            role_counts[role] += 1

        if any(role_counts.values()):
            primary_role = max(role_counts, key=role_counts.get)
            return primary_role if role_counts[primary_role] > 0 else None
        return None

    # Función para detectar proyectos
    def detect_project(messages):
        project_indicators = ['mi proyecto', 'estoy construyendo', 'estamos desarrollando',
                            'building', 'desarrollé', 'trabajando en', 'creando']
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                for indicator in project_indicators:
                    if indicator in text:
                        # Extraer la oración que contiene el indicador
                        start = max(0, text.find(indicator) - 50)
                        end = min(len(text), text.find(indicator) + 150)
                        return text[start:end].strip()
        return None

    # Función para detectar comunidades
    def detect_communities(messages):
        community_indicators = ['dao', 'comunidad', 'group', 'colectivo', 'equipo de']
        communities = set()
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                for indicator in community_indicators:
                    if indicator in text:
                        # Buscar palabras cercanas al indicador
                        words = text.split()
                        for i, word in enumerate(words):
                            if indicator in word and i < len(words) - 1:
                                communities.add(words[i+1])
        return ', '.join(communities) if communities else None

    # Función para detectar experiencia onchain
    def detect_onchain_exp(messages):
        onchain_indicators = ['deployed', 'desplegado', 'contrato', 'smart contract', 'dapp', 'token', 'nft']
        for msg in messages:
            if isinstance(msg, str):
                text = msg.lower()
                if any(indicator in text for indicator in onchain_indicators):
                    return 'Yes'
        return None

    # Función para extraer email
    def extract_email(messages):
        email_pattern = re.compile(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}')
        for msg in messages:
            if isinstance(msg, str):
                matches = email_pattern.findall(msg)
                if matches:
                    return matches[0]
        return None

    # Función para extraer social handles
    def extract_social_handle(messages):
        social_pattern = re.compile(r'@[a-zA-Z0-9_]+')
        for msg in messages:
            if isinstance(msg, str):
                matches = social_pattern.findall(msg)
                if matches:
                    # Filtrar handles que no sean menciones de Telegram
                    handles = [h for h in matches if len(h) > 2 and 'telegram' not in msg.lower()]
                    return handles[0] if handles else None
        return None

    # Inicializar recolección de datos
    users = {}
    user_messages = {}

    if 'chats' in data and 'list' in data['chats']:
        print(f"Encontrados {len(data['chats']['list'])} chats")

        for chat in data['chats']['list']:
            chat_name = chat.get('name', 'Sin nombre')
            print(f"\nProcesando chat: {chat_name}")

            if 'messages' in chat:
                print(f"  - {len(chat['messages'])} mensajes")

                for msg in chat['messages']:
                    if 'from' in msg:
                        user_id = msg.get('from_id', '')
                        username = msg.get('from', '')

                        # Extraer texto del mensaje
                        text = ""
                        if 'text' in msg:
                            if isinstance(msg['text'], str):
                                text = msg['text']
                            elif isinstance(msg['text'], list):
                                for item in msg['text']:
                                    if isinstance(item, str):
                                        text += item + " "
                                    elif isinstance(item, dict) and 'text' in item:
                                        text += item['text'] + " "

                        # Almacenar mensaje para análisis posterior
                        if user_id:
                            if user_id not in user_messages:
                                user_messages[user_id] = []
                            user_messages[user_id].append(text)

                        # Almacenar información del usuario
                        if user_id and user_id not in users:
                            # Formatear fecha en formato legible
                            date_str = msg.get('date', '')
                            try:
                                date_obj = datetime.strptime(date_str, '%Y-%m-%dT%H:%M:%S')
                                formatted_date = date_obj.strftime('%Y-%m-%d')
                            except:
                                formatted_date = date_str

                            users[user_id] = {
                                'ID': user_id,
                                'Username': username,
                                'Display Name': f"{msg.get('from_first_name', '')} {msg.get('from_last_name', '')}".strip(),
                                'Chat': chat_name,
                                'Last Activity': formatted_date,
                                'Registration date': formatted_date,  # Usar la fecha del primer mensaje como aproximación
                                'Wallet': extract_wallet(text)
                            }

        # Analizar mensajes para extraer más información
        for user_id, messages in user_messages.items():
            if user_id in users:
                # Campos técnicos
                users[user_id]['Technical Skills'] = detect_skills(messages)
                users[user_id]['Primary Role'] = detect_primary_role(messages)

                # Experiencia en áreas específicas
                users[user_id]['AI Exp'] = detect_experience(messages, ['gpt', 'machine learning', 'inteligencia artificial', 'llm', 'claude', 'chatgpt', 'ai', 'ia'])
                users[user_id]['DeFi Exp'] = detect_experience(messages, ['defi', 'finance', 'liquidity', 'yield', 'swap', 'lending', 'préstamo', 'finanzas'])
                users[user_id]['SocialFi Exp'] = detect_experience(messages, ['social', 'community', 'token social', 'reputation', 'reputación', 'comunidad'])

                # Proyecto principal
                users[user_id]['Main Project'] = detect_project(messages)

                # Comunidades
                users[user_id]['Communities'] = detect_communities(messages)

                # Experiencia onchain
                users[user_id]['Built Onchain before?'] = detect_onchain_exp(messages)

                # Programas completados
                program_keywords = ['bootcamp', 'course completed', 'curso completado', 'certificación', 'certification', 'graduated', 'graduado']
                users[user_id]['Has completed a Program?'] = detect_experience(messages, program_keywords)

                # Email y redes sociales
                users[user_id]['Email'] = extract_email(messages)
                users[user_id]['Social handle'] = extract_social_handle(messages)

                # Plataforma social (derivada del handle)
                social_handle = users[user_id]['Social handle']
                if social_handle:
                    if 'twitter' in ' '.join(messages).lower():
                        users[user_id]['Social Platform'] = 'Twitter'
                    elif 'github' in ' '.join(messages).lower():
                        users[user_id]['Social Platform'] = 'GitHub'
                    else:
                        users[user_id]['Social Platform'] = 'Unknown'

                # Next steps (campo a llenar manualmente)
                users[user_id]['Next steps'] = 'Contact for more information'

        # Crear DataFrame con los usuarios
        user_list = list(users.values())
        if user_list:
            df = pd.DataFrame(user_list)

            # Reorganizar columnas para que coincidan con el Builder Dashboard
            columns = [
                'ID', 'Wallet', 'Username', 'Display Name', 'Primary Role',
                'Technical Skills', 'AI Exp', 'SocialFi Exp', 'DeFi Exp',
                'Main Project', 'Communities', 'Built Onchain before?',
                'Has completed a Program?', 'Email', 'Social handle',
                'Social Platform', 'Registration date', 'Last Activity', 'Next steps'
            ]

            # Asegurar que todas las columnas existan
            for col in columns:
                if col not in df.columns:
                    df[col] = None

            # Reordenar columnas
            df = df[columns]

            print(f"\nEncontrados {len(df)} usuarios únicos con información detallada")

            # Guardar a CSV con codificación UTF-8
            df.to_csv('builders_dashboard_full.csv', index=False, encoding='utf-8')

            # Mostrar código para descargar
            print("\n¡Datos procesados! Para descargar el archivo, ejecuta esta celda:")
            print("\nfrom google.colab import files\nfiles.download('builders_dashboard_full.csv')")

            # Mostrar primeras filas
            print("\nPrimeras 3 filas del dashboard:")
            print(df.head(3)[['Username', 'Display Name', 'Primary Role', 'Technical Skills']])

        else:
            print("No se encontraron usuarios")
    else:
        print("Estructura de chats no encontrada en el JSON")

except Exception as e:
    print(f"✗ Error: {e}")
    import traceback
    traceback.print_exc()

from google.colab import files
files.download('builders_dashboard_full.csv')



from google.colab import drive
drive.mount('/content/drive')
